[TOC]
### 第一章 基础知识
#### 1.2 汇编语言
- 每一种cpu都有自己的汇编指令集
- 汇编语言的主体：汇编指令， 与机器语言相比更容易辨别记忆
- 例子：mov ax, bx   bx->ax
- 寄存器和编译器（将汇编指令转换成机器指令)

#### 1.3 汇编语言的组成
1. 汇编指令 : 机器码的助记符
2. 伪指令   : 无对应的机器码，由编译器执行，计算机不执行
3. 其他符号 : 如+-*/，无对应的机器码

#### 1.4 存储器
- 存放指令和数据, 即内存
- 从磁盘读数据到内存

#### 1.5 指令和数据
- 指令和数据是应用上的概念，
- 在内存和磁盘上指令和数据都是二进制信息

#### 1.6 存储单元
- 从0开始编号
- 一个存储单元为一个字节(Byte)=8bit
- 1Byte = 8bit, 1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1TB = 1024GB

#### 1.7 cpu对存储器的读写
##### cpu进行的三类信息交互
- 存储单元的地址(地址信息)
- 器件的选择，读或写的命令(控制信息)
- 读或写的数据(数据信息)

##### 总线和总线分类
- 通过电信号传输信息
- 每个cpu芯片有很多管脚，和总线相连
- 总线：专门连接cpu和其他芯片的导线， 不同总线决定不同的性能
    - 地址总线，寻址能力
    - 控制总线，控制能力
    - 数据总线，数据传送能力

- 例子：cpu向3号存储单元读或写数据
- mov ax, [3]

#### 1.8 地址总线
- 通过地址总线来指定存储器单元,决定cpu能对多大的存储单元进行寻址
- N根地址总线，可对2^N个地址单元进行寻址

#### 1.9 数据总线
- 通过数据总线来传送数据, 决定cpu和外界的数据传送速度
- N根数据总线，一次能传送N为二进制数据
- 例子，8088(8位)cpu和8086(16位)cpu传送89d8

#### 1.10 控制总线
- 通过控制总线控制外部器件，决定cpu对外部的控制能力
- N根控制总线，意味着cpu对外部有n中控制

#### 检测点1.1
1. 13，   2^N = 8 * 1024;  
2. 1024， 0， 1023
3. 1024*8， 1024
4. 1024*1024*1024， 1024*1024， 1024
5. 64, 1， 16， 4
6. 1, 1, 2, 2, 4
7. 512, 256
8. 二进制

#### 1.11 内存地址空间（概述）

#### 1.12 主板
- 器件：cpu，存储器， 外围芯片组，扩展插槽
- 器件通过总线相连
- 扩展接口：RAM内存，各类接口卡

#### 1.13 接口卡
- 接口卡直接控制外设， cpu通过接口卡实行间接控制
- 扩展插槽通过总线和cpu相连，所以接口卡也通过总线和cpu相连
- cpu通过总线向接口卡发送命令，接口卡根据cpu命令控制外设进行工作

#### 1.14 各类存储器芯片
- 从读写属性上可分为：
    - 随机存储器RAM， 可读可写， 断电会丢失
    - 只读存储器ROM， 只能读，不能写  断电不会丢失

- 从功能和连接上可分为：
    - 随机存储器， 主随机存储器:1.主板上和2.插在扩展插槽上的内存条
    - 装有BIOS的ROM
    - 接口卡上的RAM，典型的显卡的RAM，显存

#### 1.15 内存地址空间
- 假想的逻辑存储器
- 所有的物理存储器被看作一个有若干存储单元组成的逻辑存储器
- 内存地址空间的大小受cpu地址总线宽度的限制



### 第二章 寄存器
- cpu：运算器，控制器，寄存器等部件组成，靠内部总线相连，区别于外部总线
    - 运算器：信息处理
    - 寄存器： 信息存储
    - 控制器： 控制个各种器件的工作
    - 内部总线： 连接各种器件，进行数据传送

#### 2.1 通用寄存器 8086
- 包括：ax, bx, cx, dx , 16位寄存器
    - ax:  ah,  al 可分为两个8位寄存器
    - bx:  bh,  bl
    - cx:  ch,  cl
    - dx:  dh,  dl

#### 2.2 字在寄存器中的存储
- 字节：byte 有8个bit组成，可存在8为寄存器中
- 字：word， 有两个字节组成，可存在一个16位寄存器中,(高位字节和低位字节）
- 进制的讨论

#### 2.3 几条汇编指令 mov, add
|命令|操作|
|:--:|:--:|
mov ax，18| 18->ax
mov ah，78| 78->ah
add ax，8 | ax+=8
mov ax，bx| bx->ax

- 例子：
- 注意进位，会被直接抛弃
- 注意指令的两个操作对象位数应当是一致

#### 检测点2.1
1. 
    - F4A3H
    - 31A3H
    - 3123H
    - 6246H
    - 826CH
    - 6246H
    - 826CH
    - 04D8H
    - 0482H
    - 6C82H
    - D882H
    - D888H
    - D810H
    - 6246H
2. 
    mov ax, 2
    add ax, 2
    add ax, ax
    add ax, ax

#### 2.4 物理地址
- 内存单元的地址
- cpu通过物理地址访问内存单元
- 物理地址在8086中用段地址和偏移地址计算得到

#### 2.5 16位结构的cpu
- 16位结构（16位机，字长位16位）
    - 运算器一次最多可处理16位数据
    - 寄存器的最大宽度位16位
    - 寄存器和运算器的通路为16位
- 处理，传输，暂时存储16位的地址

#### 2.6 8086cpu给出的物理地址的方法
- 段地址
- 偏移地址
- 物理地址 = 段地址*16 + 偏移地址
- 例子：1230， 00c8 -> 12300 + 00c8 -> 123c8

#### 2.7 段地址*16 + 偏移地址=物理地址的本质含义

#### 2.8 段的概念

#### 检测点2.2
1. 00010H， 00010+FFFF = 1000FH
2. 1001H, 2000H

#### 2.9 段寄存器
- 4个段寄存器：cs，ds,ss,es
- cs: 用来存放指令的段地址
- ds: 内存的段地址
- ss：栈指针的段地址

#### 2.10 cs和ip
- cs:   代码段寄存器
- ip:   指令指针寄存器
- cpu将cs：ip指向的内容当作指令执行
- cs:M, ip: N,  M*16+N
- 例子：
- 工作过程
    1. 从cs：ip指向的内存单元读取指令，读取的指令进入指令缓冲器
    2. ip=ip+所读取的指令的长度，从而指向下一条指令
    3. 执行指令，转到1.重复

- FFFF0H 开机执行的第一条指令

#### 2.11 修改cs，ip的指令
- jmp 段地址：偏移地址 能够修改段地址和偏移地址
    - jmp 2AE3:3 cs=2AE3H, ip=0003H, cpu将从2AE33H处读取指令
    - jmp 3:0B16 cs=0003H, ip=0B16H, cpu降从00B46H处读取指令
- jmp 某一合法寄存器， 仅修改偏移地址ip

#### 2.12 代码段

#### 检测点2.3
- 4次

### 实验1 查看cpu和内存，用机器指令和汇编指令变成
1. 
- debug
- e 1000:0 b8 20 4e 05 16 14 bb
#### debug
##### 
|A|B|
|:--:|:--:|
r           |查看cpu寄存器的内容 
r 寄存器名   |修改寄存器内容
d 段地址：偏移地址  | 查看内存
d 段地址：起始偏移地址 结尾偏移地址 | 查看范围  
e 段地址：偏移地址 数据 数据 数据  | 修改内存中的内容
u 段地址：偏移地址 | 将内存单元中的内容翻译为汇编指令
t | cpu执行cs：ip指向的命令
a 段地址：偏移地址 |  以汇编指令的形式在内存中写入机器指令
p | 
g xx|设置断点 


### 第三章 寄存器(内存访问)

#### 3.1 内存中字的存储
- 16位存字，高8位高位字高地址，低八位低位字低地址， 两个连续内存单元来存储
- N地址字单元和N地址单元

#### 3.2 DS和[address]
- 段地址：ds, 更改段地址的值需要借助寄存器
    - mov ax, 1000
    - mov ds, ax
- [N] 内存的偏移量, 实际地址为 ds*16+N
- 8086不支持将数据直接送如段寄存器, mov ds, 1000H是错误的
- mov [0], al   从寄存器到内存
- mov al, [0]   从内存到寄存器

#### 3.3 字的传送
- 

#### 3.4 mov, add, sub指令
- mov
    |A|B|
    |:--:|:--:|
    mov 寄存器,数据 | mov ax, 8
    mov 寄存器,寄存器| mov ax, bx
    mov 寄存器,内存单元 | mov ax, [0]
    mov 内存单元,寄存器 | mov [0], ax
    * 不能是mov 内存单元 内存单元,也不能是mov 内存单元 数据

- add,sub
    |A|B|
    |:--:|:--:|
    add 寄存器,数据 | add ax, 8
    add 寄存器,寄存器| add ax, bx
    add 寄存器，内存单元| add ax, [0]
    add 内存单元,寄存器| add [0], ax
    sub 寄存器,数据 | sub ax, 8
    sub 寄存器,寄存器| sub ax, bx
    sub 寄存器，内存单元| sub ax, [0]
    sub 内存单元,寄存器| sub [0], ax
    * 不能 add 内存单元 内存单元， 也不能是 add 内存单元 数据

#### 3.5 数据段

#### 检测点 3.1
1. 2662H
2. E626H
3. E626H
4. 2662H
5. D6E6H
6. FD48H
7. 
- 


#### 3.6 栈
- LIFO

#### 3.7 cpu提供的栈机制
- push 
    - push ax
    - sp = sp-2
- pop 
    - pop ax
    - sp = sp + 2

- ss:栈顶段地址 sp:栈顶偏移地址
- ss:sp 指向栈顶地址ss*16+sp
- 栈是从高地址向低地址方向增长

#### 3.8 栈顶越界的问题
- 8086不会考虑栈顶越界，需要自己考虑，开大一点的栈空间，防止越界

#### 3.9 push, pop 指令
- push 和 pop操作都是以字为单位
|A|B|
|:--:|:--:|
push 寄存器|pop 寄存器
push 段寄存器| pop 段寄存器
push 内存单元| pop 内存单元

#### 3.10 栈段

### 实验二 用机器指令和汇编指令变成



### 第四章 第一个程序
#### 4.1 一个源程序从写出到执行的过程
- 编写汇编源程序
- 对源程序进行编译，连接
    - 程序
    - 相关的描述信息(程序多大，要占用多大内存空间)
- 执行可执行文件中的程序

#### 4.2 源程序
- 汇编指令
    - 实现程序返回 mov ax,4c00  int 21
- 伪指令 由编译器执行
    - segment 和 ends
        - 段名 segment
        -    ;
        - 段名 ends
    - end 汇编程序的结束标志
    - assume  假设

### 第五章 [BX]和loop指令

#### 
- mov ax,[bx]   将偏移地址为bx的内存单元送入ax
- loop 循环
    - mov cx, 循环词树
    - s:
    -   循环体
    - loop s

- 定义(), (ax)表示ax中的内容，(20000H)表示内存2000H的内容
- ((ds)*16+(bx))
- 约定idate表示常量
- 汇编源程序中，数据不能以字母开头， 如FFFFH, 应该为0FFFFH

#### 5.1 [BX]
- inc ax  ax+=1
